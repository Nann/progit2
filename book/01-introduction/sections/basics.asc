=== Git Basics

So, what is Git in a nutshell?
เอาล่ะ มาดูกันว่า Git in a nutshell เป็นยังไง? ส่วนนี้เป็นส่วนสำคัญที่ท่านจะต้องดูดไป เพราะเมื่อไหร่ที่ท่านเข้าใจแก่นแท้ของ Git และเข้าใจว่ามันทำงานยังไง เมื่อนั้น การใช้ Git อย่างมีประสิทธิภาพสูงสุดก็ไม่ยากละ ขณะที่เรียนรู้ Git พยายามลืม VCSs ตัวที่ผ่านๆมาให้หมด (เช่น Subversion และพวกพ้อง) เพราะมันจะป้องกันความงงที่จะเกิดขึ้นระหว่างใช้ Git ได้ Git มองและจำข้อมูลต่างกับระบบอื่นๆค่อนข้างเยอะ แม้ว่า UI มันจะดูคล้ายๆตัวอื่นก็ตาม ทำความเข้าใจความแตกต่าง แล้วเวลาใช้จะไม่งง.(((Subversion)))(((Perforce)))

==== Snapshots, ไม่ใช่ความเปลี่ยนแปลง

หลักๆเลย Git ต่างกับ VCS อื่นๆ (Subversion และเพื่อนๆ) ตรงที่วิธีที่ Git มองข้อมูลที่มันเก็บ โดยคอนเซปแล้ว ระบบอื่นๆจะเก็บข้อมูลในรูปของ listของความเปลี่ยนแปลง
ระบบเหล่านี้ (CVS, Subversion, Perforce, Bazaar ฯลฯ) คิดว่าข้อมูลที่มันเก็บคือ set ของ files และความเปลี่ยนแปลงที่เกิดขึ้นกับแต่ละ file ในเวลาที่ดำเนินไป

.Storing data as changes to a base version of each file.
image::images/deltas.png[Storing data as changes to a base version of each file.]

Git ไม่ได้มองหรือจำข้อมูลที่มันเก็บอย่างนั้น ในทางกลับกัน Git มองข้อมูลมันเหมือนกับเป็น set ของ snapshots ของ filesystem ขนาดจิ๋ว ทุกๆครั้งที่คุณ commit
หรือ save project ใน Git มันจะถ่ายรูปว่า files ของเราหน้าตาเป็นไง ณ บัดนั้น และเก็บ reference ไปยัง snapshot (รูปถ่าย) นั้น และเพื่อให้มีประสิทธิภาพ
ถ้า file ไม่ถูกแก้ไข Git จะไม่จำ file นั้นๆซ้ำ แค่เก็บ link ไปยัง file เก่าที่เหมือนกันเป๊ะๆ ที่มันเคยจำไว้แล้วเฉยๆ *stream of snapshots*.

.Storing data as snapshots of the project over time.
image::images/snapshots.png[Git stores data as snapshots of the project over time.]

นี่ความความแตกต่างที่สำคัญระหว่าง Git และ VCSs อื่นๆเกือบทั่วโลก มันทำให้ Git ต้องคิดใหม่ ทำใหม่เกือบทุกๆอย่าง ขณะที่ระบบอื่นๆแค่ copy มาจากรุ่นก่อนๆ
มันทำให้ Git เหมือนเป็น filesystem ขนาดจิ๋วที่มากับ tools อันทรงพลังที่สร้างขึ้นมาครอบมันมากกว่าที่จะเป็นแค่ VCS ธรรมดา
เด๋วเราค่อยมาโชว์ของดีที่ได้จากการมองข้อมูลในลักษณะนี้ในหัวข้อ branching ใน Chapter 3 <<_git_branching>>.

==== Nearly Every Operation Is Local

ส่วนใหญ่แล้ว operation ใน Git ต้องการแค่ file และทรัพยากรบนเครื่องในการทำงาน ไม่จำเป็นต้องมีข้อมูลอื่นใดจากเครื่องอื่นๆใน network ถ้าคุณคุ้นเคยกับ CVCS ที่ operation ส่วนใหญ่ต้องทนกับความช้าของ network แล้วละก็ คุณจะรู้สึกราวกับว่าเทพแห่งความเร็วนั้นอวยพร Git ด้วยความเร็วส์ที่ไม่อายบรรยาย เพราะว่าคุณมี history ทั้งหมดของ project เก็บอยู่ที่นี่ในเครื่องของตัวเอง operation ทั้งหลายแหล่จึงรวดเร็วทันใจ

ยกตัวอย่างเช่นการค้นหา history ของ project Git ไม่จำเป็นต้องวิ่งไป server เพื่อดึง history แล้วหิ้วกลับมาแสดงผลให้คุณ มันแค่อ่านจาก database บนเครื่องก็ได้แล้ว นั่นหมายความว่าคุณสามารถเห็น project history ได้ในอึดใจเดียว ถ้าอยากดูความเปลี่ยนแปลงที่เกิดขึ้นบน file ซักอันระหว่าง version ปัจจุบันกับเมื่อเดือนที่แล้ว Git สามารถค้นหา file เมื่อเดือนที่แล้วบนเครื่องแล้วคำนวนหาสิ่งที่เปลี่ยนแปลงไปให้ได้ทันที แทนที่จะต้องไปอ้อน server ที่อยู่ไกลๆให้คำนวนให้หรือไปขอ file เดือนก่อนจาก server แล้วค่อยเอามาคำนวน

นั่นหมายความว่าคุณแทบจะไม่มีอะไรที่ทำไม่ได้ในกรณีที่ไม่ได้ต่อเนตหรือต่อ VPN ไม่ว่าจะกำลังนั่งรถ นั่งเรือ นั่งเครื่องบินอยู่ ถ้ามีอะไรกระจุ๊กกระจิ๊กอยากทำก็สามารถทำแล้ว commit เก็บไว้ได้อย่างสบายอารมณ์ ไว้ต่อเนตได้เมื่อไหร่ก็ค่อย upload ถ้าสมมติอยู่บ้านแล้วไม่สามารถ set VPN ได้ ก็ยังจะทำงานได้อยู่ ถ้าเป็นระบบอื่นๆ จะทำให้ได้แบบนี้แทบจะเป็นไปไม่ได้ ถึงได้ก็เลือดตาแทบกระเด็นหล่ะ เช่นสมมติใช้ Perforce คุณแทบจะทำอะไรไม่ได้เลยถ้าไม่ต่ออยู่กับ server หรือกรณี Subversion และ CVS ถึงจะแก้ file ได้ ก็ commit ใส่ database ไม่ได้ (เพราะไม่ได้ต่อกับ database) ถึงเรื่องแค่นี้จะดูเป็นเรื่องเล็ก แต่ถ้าลองได้ใช้จริงจะรู้ว่าชีวิตมันรู้สึกแตกต่างกันขนาดไหน

==== Git นั้นเที่ยงธรรม

ทุกอย่างใน Git ถูก checksum ก่อนจะถูก save และจะถูกอ้างอิงถึงด้วย checksum นั้นๆ นั่นหมายความว่าไม่มีทางที่จะมีข้อมูลใน file หรือ directory เปลี่ยนไปโดยที่ Git จะไม่รู้เรื่อง ความสามารถนี้ถูกฝังไว้ในแก่นลึกสุดใจของ Git และหล่อหลอมเข้ากับจิตวิญญาณของมัน คุณไม่มีวันเจอ file เสียหรือพังไประหว่างถ่ายโอนข้อมูลโดยที่ Git ตรวจจับไม่เจอแน่นอน

กลไกที่ Git ใช้ในการทำ checksum เรียกว่า SHA-1 hash ซึ่งเป็นเลขฐาน 16 ยาว 40 ตัวอักษรที่ถูกคำนวนมาจากเนื้อหาภายใน file หรือโครงสร้าง directory ภายใน Git SHA-1 hash มีหน้าตาประมาณนี้

[source]
----
24b9da6552252987aa493b52f8696cd6d3b00373
----

คุณจะเห็นค่า hash เหล่านี้กระจายตัวอยู่ทั่ว Git มันถูกใช้เยอะมว้ากก เอาจริงๆแล้ว Git ไม่ได้เก็บข้อมูลเป็น file แต่เก็บลง database ซึ่งสามารถเข้าถึงข้อมูลได้ด้วยค่า hash ของเนื้อหาใน file

==== Git Generally Only Adds Data

When you do actions in Git, nearly all of them only add data to the Git database.
It is hard to get the system to do anything that is not undoable or to make it erase data in any way.
As in any VCS, you can lose or mess up changes you haven't committed yet; but after you commit a snapshot into Git, it is very difficult to lose, especially if you regularly push your database to another repository.

This makes using Git a joy because we know we can experiment without the danger of severely screwing things up.
For a more in-depth look at how Git stores its data and how you can recover data that seems lost, see <<_undoing>>.

==== The Three States

Now, pay attention.
This is the main thing to remember about Git if you want the rest of your learning process to go smoothly.
Git has three main states that your files can reside in: committed, modified, and staged.
Committed means that the data is safely stored in your local database.
Modified means that you have changed the file but have not committed it to your database yet.
Staged means that you have marked a modified file in its current version to go into your next commit snapshot.

This leads us to the three main sections of a Git project: the Git directory, the working directory, and the staging area.

.Working directory, staging area, and Git directory.
image::images/areas.png["Working directory, staging area, and Git directory."]

The Git directory is where Git stores the metadata and object database for your project.
This is the most important part of Git, and it is what is copied when you clone a repository from another computer.

The working directory is a single checkout of one version of the project.
These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.

The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit.
It's sometimes referred to as the ``index'', but it's also common to refer to it as the staging area.

The basic Git workflow goes something like this:

1. You modify files in your working directory.
2. You stage the files, adding snapshots of them to your staging area.
3. You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.

If a particular version of a file is in the Git directory, it's considered committed.
If it's modified but has been added to the staging area, it is staged.
And if it was changed since it was checked out but has not been staged, it is modified.
In <<_git_basics_chapter>>, you'll learn more about these states and how you can either take advantage of them or skip the staged part entirely.
